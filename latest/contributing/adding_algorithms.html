<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Adding Algorithms · DiffEq Developer Documentation</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="DiffEq Developer Documentation logo"/></a><h1>DiffEq Developer Documentation</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Contributor Guide</span><ul><li><a class="toctext" href="ecosystem_overview.html">Ecosystem Overview</a></li><li class="current"><a class="toctext" href="adding_algorithms.html">Adding Algorithms</a><ul class="internal"><li><a class="toctext" href="#Adding-new-algorithms-to-OrdinaryDiffEq-1">Adding new algorithms to OrdinaryDiffEq</a></li></ul></li><li><a class="toctext" href="defining_problems.html">Developing A New Problem</a></li><li><a class="toctext" href="diffeq_internals.html">The DiffEq Internals</a></li><li><a class="toctext" href="parameters.html">The Parameters Interface</a></li><li><a class="toctext" href="type_traits.html">Type Traits</a></li></ul></li><li><span class="toctext">Algorithm Development Tools</span><ul><li><a class="toctext" href="../alg_dev/test_problems.html">Test Problems</a></li><li><a class="toctext" href="../alg_dev/convergence.html">Convergence Simulations</a></li><li><a class="toctext" href="../alg_dev/benchmarks.html">Benchmark Suite</a></li></ul></li><li><span class="toctext">Internal Documentation</span><ul><li><a class="toctext" href="../internals/fem_tools.html">Internal Finite Element Tools</a></li><li><a class="toctext" href="../internals/notes_on_algorithms.html">Notes on Algorithms</a></li><li><a class="toctext" href="../internals/tableaus.html">ODE Tableaus</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Contributor Guide</li><li><a href="adding_algorithms.html">Adding Algorithms</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDevDocs.jl/tree/99ddd5e550c1c50579a21ec2698ba80e9b0dc463/docs/src/contributing/adding_algorithms.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Adding Algorithms</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Adding-Algorithms-1" href="#Adding-Algorithms-1">Adding Algorithms</a></h1><p>New algorithms can either be added by extending one of the current solver (or add-on packages), or by contributing a new package to the organization. If it&#39;s a new problem (a new PDE, a new type of differential equation, a new subclass of problems for which special methods exist, etc.) then the problem and solution types should be added to <code>DiffEqBase</code> first.</p><p>After the problem and solutions are defined, the <code>solve</code> method should be implemented. It should take in keyword arguments which match the common interface (implement &quot;as many as possible&quot;). One should note and document the amount of compatibility with the common interface and Julia-defined types. After that, testing should be done using <code>DiffEqDevTools</code>. Convergence tests and benchmarks should be included to show the effectiveness of the algorithm and the correctness. Do not worry if the algorithm is not &quot;effective&quot;: the implementation can improve over time and some algorithms useful just for the comparison they give!</p><p>After some development, one may want to document the algorithm in DiffEqBenchmarks and DiffEqTutorials.</p><h2><a class="nav-anchor" id="Adding-new-algorithms-to-OrdinaryDiffEq-1" href="#Adding-new-algorithms-to-OrdinaryDiffEq-1">Adding new algorithms to OrdinaryDiffEq</a></h2><p>This recipe has been used to add the strong stability preserving Runge-Kutta methods <code>SSPRK22</code>, <code>SSPRK33</code>, and <code>SSPRK104</code> to <code>OrdinaryDiffEq</code>. <code>SSPRK22</code> will be used as an example.</p><ul><li><p>To create a new solver, two (three) types have to be created. The first is the algorithm <code>SSPRK22</code> used for dispatch, the other ones are the corresponding caches <code>SSPRK22Cache</code> (for inplace updates) and <code>SSPRK22ConstantCache</code>.</p></li><li><p>The algorithm is defined in <code>algorithms.jl</code> as <code>immutable SSPRK22 &lt;: OrdinaryDiffEqAlgorithm end</code>. Although it has not the FSAL property, this is set to true since the derivative at the start and the end of the interval are used for the Hermite interpolation, and so this is FSAL&#39;d so that way only a single extra function evaluation occurs over the whole integration. This is done in <code>alg_utils.jl</code> via <code>isfsal(alg::SSPRK22) = true</code>. Additionally, the order is set in the same file via <code>alg_order(alg::SSPRK22) = 2</code>.</p></li><li><p>The algorithm <code>SSPRK22</code>is exported in <code>OrdinaryDiffEq.jl</code>.</p></li><li><p>In <code>caches.jl</code>, the two cache types <code>SSPRK22Cache</code> (for inplace updates) and <code>SSPRK22ConstantCache</code> are defined, similarly to the other ones. Note: <code>u_cache(c::SSPRK22Cache) = ()</code> and <code>du_cache(c::SSPRK22Cache) = (c.k,c.du,c.fsalfirst)</code> return the parts of the modifiable cache that are changed if the size of the ODE changes.</p></li><li><p>A new file <code>integrators/ssprk_integrators.jl</code>has been used for the new implementations. For both types of caches, the functions <code>initialize!</code> and <code>perform_step!</code> are defined there.</p></li><li><p>Finally, tests are added. A new file <code>test/ode/ode_ssprk_tests.jl</code> is created and included in <code>tests/runtests.jl</code> via  <code>@time @testset &quot;SSPRK Tests&quot; begin include(&quot;ode/ode_ssprk_tests.jl&quot;) end</code>.</p></li><li><p>Additionally, regression tests for the dense output are added in <code>test/ode/ode_dense_tests.jl</code>.</p></li></ul><p>For more details, refer to https://github.com/JuliaDiffEq/OrdinaryDiffEq.jl/pull/40</p><footer><hr/><a class="previous" href="ecosystem_overview.html"><span class="direction">Previous</span><span class="title">Ecosystem Overview</span></a><a class="next" href="defining_problems.html"><span class="direction">Next</span><span class="title">Developing A New Problem</span></a></footer></article></body></html>
